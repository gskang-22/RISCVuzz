#include "client.h"

#include <stdlib.h>
#include <fcntl.h>
#include <string.h>
#include <sys/mman.h>
#include <unistd.h>
#include <signal.h>
#include <setjmp.h>
#include <ucontext.h>

extern size_t sandbox_size;
extern const char *reg_names[32];
extern uint64_t temp_storage[];
extern uint64_t xreg_output_data[];
extern void signal_trampoline(); // from assembly
extern size_t start_offset;

sigjmp_buf jump_buffer;
ucontext_t saved_context;
uint64_t regs_before[32];
uint64_t regs_after[32];
static char alt_stack[SIGSTKSZ]; // Signal alternate stack

size_t page_size = 4096;
size_t sandbox_pages = 1; // 4 KB sandbox
size_t guard_pages = 16;  // 64 KB guards (tunable)

/*
Code for client (RISC-V board)
Aim:
    1. Run the instruction set generated by the server
    2. Sends the results back to the server (registers and memory states)

Things to consider:
    1. Smart filtering of immediates
    2. if a signal is triggered vs no signal triggered
    3. Handling infinite loops
    4. Unmapping Kernel-Provided Sections (vdso, vvar, etc.)
    5. run twice Detecting Naturally Non-Deterministic Instructions

*/

// allocates a memory buffer to write to and execute
// required for dynamic code injection
uint8_t *allocate_executable_buffer()
{
    size_t total_pages = sandbox_pages + 2 * guard_pages;
    size_t total_size = total_pages * page_size;

    void *buf = mmap(NULL, total_size,
                     PROT_NONE,
                     MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);

    if (buf == MAP_FAILED)
    {
        perror("mmap");
        exit(1);
    }

    uint8_t *sandbox = buf + guard_pages * page_size;
    return sandbox;
}

void prepare_sandbox(uint8_t *sandbox_ptr)
{
    // Reset sandbox to PROT_NONE after each run
    if (mprotect(sandbox_ptr, sandbox_size, PROT_NONE) != 0)
    {
        perror("mprotect NONE");
        exit(1);
    }
}

void inject_instructions(uint8_t *sandbox_ptr, const uint32_t *instrs, size_t num_instrs)
{
    // enable write access
    if (mprotect(sandbox_ptr, sandbox_pages * page_size, PROT_READ | PROT_WRITE) != 0)
    {
        perror("mprotect");
        exit(1);
    }
    // Fill sandbox with ebreak (0x00100073)
    size_t num_words = sandbox_size / sizeof(uint32_t);
    for (size_t i = 0; i < num_words; i++)
    {
        sandbox_ptr[i] = 0x00100073;
    }

    // copy fuzzed instructions
    memcpy(sandbox_ptr + start_offset, instrs, num_instrs * sizeof(uint32_t));

    // flush instruction cache, preventing inconsisten results
    asm volatile("fence.i" ::: "memory");

    // make page executable
    if (mprotect(sandbox_ptr, sandbox_size, PROT_READ | PROT_EXEC) != 0)
    {
        perror("mprotect RX");
        exit(1);
    }
}

// Signal handler for SIGILL and SIGSEGV
void signal_handler(int signo, siginfo_t *info, void *context)
{
    ucontext_t *uc = (ucontext_t *)context;
    saved_context = *uc; // Save the context for inspection after jump

    // storing values into general registers
    for (int i = 0; i < 32; i++)
    {
        xreg_output_data[i] = uc->uc_mcontext.__gregs[i];
    }
    // printf("sp: %ld\n", uc->uc_mcontext.__gregs[1]);
    // printf("gp: %ld\n", uc->uc_mcontext.__gregs[2]);
    // printf("tp: %ld\n", uc->uc_mcontext.__gregs[3]);
    // printf("fp: %ld\n", uc->uc_mcontext.__gregs[4]);

    switch (signo)
    {
    case SIGILL:
        printf("Caught SIGILL (Illegal Instruction)\n");
        printf("Faulting address: %p\n", info->si_addr);
        break;
    case SIGSEGV:
        printf("Caught SIGSEGV (Segmentation Fault)\n");
        printf("Faulting address: %p\n", info->si_addr);
        break;
    case SIGBUS:
        printf("Caught SIGBUS (Bus Error)\n");
        break;
    case SIGFPE:
        printf("Caught SIGFPE (Floating Point Exception)\n");
        break;
    case SIGTRAP:
        printf("Caught SIGTRAP: EBREAK\n");
        break;
    default:
        printf("Caught signal %d\n", signo);
    }
    siglongjmp(jump_buffer, 1);
}

// Setup signal handlers
void setup_signal_handlers()
{
    // install alt stack (to allow clobbering of sp)
    stack_t ss;
    ss.ss_sp = alt_stack;
    ss.ss_size = sizeof(alt_stack);
    ss.ss_flags = 0;
    sigaltstack(&ss, NULL);

    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_sigaction = (void *)signal_trampoline;
    sa.sa_flags = SA_SIGINFO | SA_ONSTACK;

    sigemptyset(&sa.sa_mask);
    sigaction(SIGILL, &sa, NULL);
    sigaction(SIGSEGV, &sa, NULL);
    sigaction(SIGBUS, &sa, NULL);
    sigaction(SIGFPE, &sa, NULL);
    sigaction(SIGTRAP, &sa, NULL);
}

void unmap_vdso_vvar()
{
    FILE *maps = fopen("/proc/self/maps", "r");
    if (!maps)
    {
        perror("fopen /proc/self/maps");
        exit(EXIT_FAILURE);
    }

    char line[256];
    while (fgets(line, sizeof(line), maps))
    {
        if (strstr(line, "[vdso]") || strstr(line, "[vdso_data]") || strstr(line, "[vvar]"))
        {
            unsigned long start, end;
            if (sscanf(line, "%lx-%lx", &start, &end) == 2)
            {
                printf("Unmapping %lx - %lx\n", start, end);
                if (munmap((void *)start, end - start) != 0)
                {
                    perror("Warning: unmapping has failed!!");
                }
            }
        }
    }
    fclose(maps);
}

void print_reg_changes(uint64_t regs_before[32], uint64_t regs_after[32])
{

    for (int i = 0; i < 32; i++)
    {
        if (regs_before[i] != regs_after[i])
        {
            printf("%-4s changed: 0x%016lx -> 0x%016lx\n",
                   reg_names[i], regs_before[i], regs_after[i]);
        }
    }
}

void compare_reg_changes(uint64_t regs_before[32], uint64_t regs_after[32])
{
    for (int i = 0; i < 32; i++)
    {
        if (regs_before[i] != regs_after[i])
        {
            printf("WARNING: Register x%d differs: 0x%016lx -> 0x%016lx\n",
                   i, regs_before[i], regs_after[i]);
        }
    }
}
