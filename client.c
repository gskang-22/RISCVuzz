#include "client.h"


#include <stdlib.h>
#include <fcntl.h>
#include <string.h>
#include <sys/mman.h>
#include <unistd.h>
#include <signal.h>
#include <setjmp.h>
#include <ucontext.h>

extern size_t sandbox_size;
extern const char *reg_names[32];
extern uint64_t temp_storage[];
extern uint64_t xreg_output_data[];

sigjmp_buf jump_buffer;
ucontext_t saved_context;
uint64_t regs_before[32];
uint64_t regs_after[32];

/*
Code for client (RISC-V board)
Aim:
    1. Run the instruction set generated by the server
    2. Sends the results back to the server (registers and memory states)

Things to consider:
    1. Smart filtering of immediates
    2. if a signal is triggered vs no signal triggered
    3. Handling infinite loops
    4. Unmapping Kernel-Provided Sections (vdso, vvar, etc.)
    5. run twice Detecting Naturally Non-Deterministic Instructions

*/

// allocates a memory buffer to write to and execute
// required for dynamic code injection
uint8_t *allocate_executable_buffer(size_t size)
{
    size_t total_size = 5 * size; // 2 Guard + 1 sandbox + 2 Guard pages
    void *buf = mmap(NULL, total_size,
                     PROT_NONE,
                     MAP_ANONYMOUS | MAP_PRIVATE , -1, 0);

    if (buf == MAP_FAILED)
    {
        perror("mmap");
        exit(1);
    }

    uint8_t *sandbox = buf + 2 * size;
    if (mprotect(sandbox, size, PROT_READ | PROT_WRITE | PROT_EXEC) != 0) {
        perror("mprotect");
        exit(1);
    }

    return sandbox;
}

void inject_instructions(uint8_t *buf, const uint32_t *instrs, size_t num_instrs, size_t start_offset, size_t size)
{
    // Fill page with ebreak padding (0x00100073)
    for (size_t i = 0; i < size / 4; i++)
    {
        ((uint32_t *)buf)[i] = 0x00100073;
    }

    memcpy(buf + start_offset, instrs, num_instrs * sizeof(uint32_t));
        asm volatile ("fence.i" ::: "memory");
}

// Signal handler for SIGILL and SIGSEGV
void signal_handler(int signo, siginfo_t *info, void *context)
{
    ucontext_t *uc = (ucontext_t *)context;
    saved_context = *uc; // Save the context for inspection after jump

    // storing values into general registers
    for (int i = 0; i < 32; i++) {
        xreg_output_data[i] = uc->uc_mcontext.__gregs[i];
    }
    // printf("sp: %ld\n", uc->uc_mcontext.__gregs[1]);
    // printf("gp: %ld\n", uc->uc_mcontext.__gregs[2]);
    // printf("tp: %ld\n", uc->uc_mcontext.__gregs[3]);
    // printf("fp: %ld\n", uc->uc_mcontext.__gregs[4]);

    switch (signo)
    {
    case SIGILL:
        printf("Caught SIGILL (Illegal Instruction)\n");
	printf("Faulting address: %p\n", info->si_addr);
        break;
    case SIGSEGV:
        printf("Caught SIGSEGV (Segmentation Fault)\n");
        printf("Faulting address: %p\n", info->si_addr);
        break;
    case SIGBUS:
        printf("Caught SIGBUS (Bus Error)\n");
        break;
    case SIGFPE:
        printf("Caught SIGFPE (Floating Point Exception)\n");
        break;
    case SIGTRAP:
        printf("Caught SIGTRAP: EBREAK\n");
        break;
    default:
        printf("Caught signal %d\n", signo);
    }
    // uc->uc_mcontext.__gregs[REG_PC] += 4; // advance PC by 4 bytes
    siglongjmp(jump_buffer, 1);
}

// Setup signal handlers
void setup_signal_handlers()
{
    struct sigaction sa;

    memset(&sa, 0, sizeof(sa));
    sa.sa_sigaction = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_SIGINFO | SA_ONSTACK;
    sigaction(SIGILL, &sa, NULL);
    sigaction(SIGSEGV, &sa, NULL);
    sigaction(SIGBUS, &sa, NULL);
    sigaction(SIGFPE, &sa, NULL);
    sigaction(SIGTRAP, &sa, NULL);
}

void unmap_vdso_vvar()
{
    FILE *maps = fopen("/proc/self/maps", "r");
    if (!maps)
    {
        perror("fopen /proc/self/maps");
        exit(EXIT_FAILURE);
    }

    char line[256];
    while (fgets(line, sizeof(line), maps))
    {
        if (strstr(line, "[vdso]") || strstr(line, "[vdso_data]") || strstr(line, "[vvar]"))
        {
            unsigned long start, end;
            if (sscanf(line, "%lx-%lx", &start, &end) == 2)
            {
                printf("Unmapping %lx - %lx\n", start, end);
                if (munmap((void *)start, end - start) != 0)
                {
                    perror("Warning: unmapping has failed!!");
                }
            }
        }
    }
    fclose(maps);
}

void print_reg_changes(uint64_t regs_before[32], uint64_t regs_after[32])
{

    for (int i = 0; i < 32; i++)
    {
        if (regs_before[i] != regs_after[i])
        {
            printf("%-4s changed: 0x%016lx -> 0x%016lx\n",
                   reg_names[i], regs_before[i], regs_after[i]);
        }
    }
}

void compare_reg_changes(uint64_t regs_before[32], uint64_t regs_after[32])
{
    for (int i = 0; i < 32; i++)
    {
        if (regs_before[i] != regs_after[i])
        {
            printf("WARNING: Register x%d differs: 0x%016lx -> 0x%016lx\n",
                   i, regs_before[i], regs_after[i]);
        }
    }
}
