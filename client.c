#include "client.h"                                                                                 
                                                                                                    
#include <stdlib.h>                                                                                 
#include <fcntl.h>                                                                                  
#include <string.h>                                                                                 
#include <sys/mman.h>                                                                               
#include <unistd.h>                                                                                 
#include <signal.h>                                                                                 
#include <setjmp.h>                                                                                 
#include <ucontext.h>                                                                               
                                                                                                    
extern size_t sandbox_size;                                                                         
extern uint8_t *sandbox;                                                                            
extern const char* reg_names[32];                                                                   
                                                                                                    
sigjmp_buf jump_buffer;                                                                             
ucontext_t saved_context;                                                                           
uint64_t regs_before[32];                                                                           
uint64_t regs_after[32];                                                                            
                                                                                                    
/*                                                                                                  
Code for client (RISC-V board)                                                                      
Aim:                                                                                                
    1. Run the instruction set generated by the server                                              
    2. Sends the results back to the server (registers and memory states)                           
                                                                                                    
Things to consider:                                                                                 
    1. Smart filtering of immediates                                                                
    2. if a signal is triggered vs no signal triggered                                              
    3. Handling infinite loops                                                                      
    4. Unmapping Kernel-Provided Sections (vdso, vvar, etc.)                                        
    5. run twice Detecting Naturally Non-Deterministic Instructions                                 
                                                                                                    
*/                                                                                                  
                                                                                                    
// allocates a memory buffer to write to and execute                                                
// required for dynamic code injection                                                              
uint8_t *allocate_executable_buffer(size_t size) {                                                  
    void *buf = mmap(NULL, size,                                                                    
                     PROT_READ | PROT_WRITE | PROT_EXEC,                                            
                     MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);                                           
    if (buf == MAP_FAILED) {                                                                        
        perror("mmap");                                                                             
        exit(EXIT_FAILURE);                                                                         
    }                                                                                               
    return (uint8_t *)buf;                                                                          
}                                                                                                   
                                                                                                    
void inject_instructions(uint8_t *buf, const uint32_t *instrs, size_t num_instrs) {                 
        memcpy(buf, instrs, num_instrs * sizeof(uint32_t));                                         
}                                                                                                   
                                                                                                    
// Signal handler for SIGILL and SIGSEGV                                                            
void signal_handler(int signo, siginfo_t *info, void *context) {                                    
    ucontext_t *uc = (ucontext_t *)context;                                                         
    saved_context = *uc;  // Save the context for inspection after jump                             
                                                                                                    
    switch (signo) {                                                                                
        case SIGILL:                                                                                
            printf("Caught SIGILL (Illegal Instruction)\n");                                        
            break;                                                                                  
        case SIGSEGV:                                                                               
            printf("Caught SIGSEGV (Segmentation Fault)\n");                                        
            printf("Faulting address: %p\n", info->si_addr);                                        
            break;                                                                                  
        case SIGBUS:                                                                                
            printf("Caught SIGBUS (Bus Error)\n");                                                  
            break;                                                                                  
        case SIGFPE:                                                                                
            printf("Caught SIGFPE (Floating Point Exception)\n");                                   
            break;                                                                                  
        case SIGTRAP:                                                                               
            printf("Caught SIGTRAP: EBREAK\n");                                                     
            uc->uc_mcontext.__gregs[REG_PC] += 4;  // advance PC by 4 bytes                         
            return;                                                                                 
        default:                                                                                    
            printf("Caught signal %d\n", signo);                                                    
    }                                                                                               
    siglongjmp(jump_buffer, 1);                                                                     
}                                                                                                   
                                                                                                    
// Setup signal handlers                                                                            
void setup_signal_handlers() {                                                                      
    struct sigaction sa;                                                                            
                                                                                                    
    memset(&sa, 0, sizeof(sa));                                                                     
    sa.sa_sigaction = signal_handler;                                                               
    sigemptyset(&sa.sa_mask);                                                                       
    sa.sa_flags = SA_SIGINFO | SA_RESTART;                                                          
                                                                                                    
    sigaction(SIGILL, &sa, NULL);                                                                   
    sigaction(SIGSEGV, &sa, NULL);                                                                  
    sigaction(SIGBUS, &sa, NULL);                                                                   
    sigaction(SIGFPE, &sa, NULL);                                                                   
    sigaction(SIGTRAP, &sa, NULL);                                                                  
}                                                                                                   
                                                                                                    
void print_reg_changes(uint64_t regs_before[32], uint64_t regs_after[32]) {                         
                                                                                                    
    for (int i = 0; i < 32; i++) {                                                                  
        if (regs_before[i] != regs_after[i]) {                                                      
            printf("%-4s changed: 0x%016lx -> 0x%016lx\n",                                          
                reg_names[i], regs_before[i], regs_after[i]);                                       
        }                                                                                           
    }                                                                                               
}  