#include "client.h"

#include <stdlib.h>
#include <fcntl.h>
#include <string.h>
#include <sys/mman.h>
#include <unistd.h>
#include <signal.h>
#include <setjmp.h>
#include <ucontext.h>

extern size_t sandbox_size;
extern const char *reg_names[32];
extern uint64_t temp_storage[];
extern uint64_t xreg_output_data[];
extern uint64_t freg_output_data[];
extern size_t start_offset;
extern void signal_trampoline(); // from assembly

typedef struct {
    void  *addr;
    size_t len;
} mapped_region_t;

sigjmp_buf jump_buffer;
ucontext_t saved_context;
uint64_t regs_before[32];
uint64_t regs_after[32];

uint64_t fcsr_output_data;
char alt_stack[SIGSTKSZ]; // Signal alternate stack

static volatile sig_atomic_t g_faults_this_run = 0;
static volatile uintptr_t g_fault_addr = 0;
static mapped_region_t *g_regions = NULL;
static size_t g_regions_len = 0;
static size_t g_regions_cap = 0;
static size_t g_pagesize = 0;

size_t page_size = 4096;
size_t sandbox_pages = 1; // 4 KB sandbox
size_t guard_pages = 16;  // 64 KB guards (tunable)
#define MAX_FAULTS_PER_RUN 10
/*
Code for client (RISC-V board)
Aim:
    1. Run the instruction set generated by the server
    2. Sends the results back to the server (registers and memory states)

Things to consider:
    1. Smart filtering of immediates
    2. if a signal is triggered vs no signal triggered
    3. Handling infinite loops
    4. Unmapping Kernel-Provided Sections (vdso, vvar, etc.)
    5. run twice Detecting Naturally Non-Deterministic Instructions

*/

// allocates a memory buffer to write to and execute
// required for dynamic code injection
uint8_t *allocate_executable_buffer()
{
    size_t total_pages = sandbox_pages + 2 * guard_pages;
    size_t total_size = total_pages * page_size;

    void *buf = mmap(NULL, total_size,
                     PROT_NONE,
                     MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);

    if (buf == MAP_FAILED)
    {
        perror("mmap");
        exit(1);
    }

    uint8_t *sandbox = buf + guard_pages * page_size;
    return sandbox;
}

void prepare_sandbox(uint8_t *sandbox_ptr)
{
    // Reset sandbox to PROT_NONE after each run
    if (mprotect(sandbox_ptr, page_size * sandbox_pages, PROT_NONE) != 0)
    {
        perror("mprotect NONE");
        exit(1);
    }
}

void inject_instructions(uint8_t *sandbox_ptr, const uint32_t *instrs, size_t num_instrs)
{
    // enable write access
    if (mprotect(sandbox_ptr, sandbox_pages * page_size, PROT_READ | PROT_WRITE) != 0)
    {
        perror("mprotect");
        exit(1);
    }

    // Fill sandbox with ebreak (0x00100073)
    // for (size_t i = 0; i < sandbox_pages * page_size; i += 4) {
    //     *(uint32_t *)(sandbox_ptr + i) = 0x00100073;
    // }

    // fill 2 ebreaks before the sandboxed instructions
    for (size_t i = 0; i < 2 * sizeof(uint32_t); i += 4)
        *(uint32_t *)(sandbox_ptr + start_offset - 2 * sizeof(uint32_t) + i) = 0x00100073;

    // fill 2 ebreaks after the sandboxed instructions
    for (size_t i = 0; i < 2 * sizeof(uint32_t); i += 4)
        *(uint32_t *)(sandbox_ptr + start_offset + num_instrs * sizeof(uint32_t) + i) = 0x00100073;

    // copy fuzzed instructions
    memcpy(sandbox_ptr + start_offset, instrs, num_instrs * sizeof(uint32_t));

    // flush instruction cache, preventing inconsistent results
    asm volatile("fence.i" ::: "memory");

    // make page executable
    if (mprotect(sandbox_ptr, sandbox_pages * page_size, PROT_READ | PROT_EXEC) != 0)
    {
        perror("mprotect RX");
        exit(1);
    }
}

// Signal handler for SIGILL and SIGSEGV
void signal_handler(int signo, siginfo_t *info, void *context)
{
    ucontext_t *uc = (ucontext_t *)context;
    // saved_context = *uc; // Save the context for inspection after jump
    void *fault_addr = info->si_addr;

    // === Save general-purpose registers (x0-x31) ===
    for (int i = 0; i < 32; i++)
    {
        xreg_output_data[i] = uc->uc_mcontext.__gregs[i];
    }
    
    // === Save floating-point registers if available ===
    union __riscv_mc_fp_state *fpstate = &uc->uc_mcontext.__fpregs;
    // Check if FP state is valid (might need a different check than NULL)
    if (uc->uc_mcontext.__fpregs.__d.__f[0] != 0) {  // or some other appropriate check
        for (int i = 0; i < 32; i++) {
            freg_output_data[i] = fpstate->__d.__f[i];
        }

        fcsr_output_data = fpstate->__d.__fcsr;
    } else {
        memset(freg_output_data, 0, sizeof(uint64_t) * 32);
        fcsr_output_data = 0;
    }
    
    // printf("sp: %ld\n", uc->uc_mcontext.__gregs[1]);
    // printf("gp: %ld\n", uc->uc_mcontext.__gregs[2]);
    // printf("tp: %ld\n", uc->uc_mcontext.__gregs[3]);
    // printf("fp: %ld\n", uc->uc_mcontext.__gregs[4]);

    switch (signo)
    {
    case SIGILL:
        printf("Caught SIGILL (Illegal Instruction)\n");
        printf("Faulting address: %p\n", fault_addr);
        break;
    case SIGSEGV:
        printf("Caught SIGSEGV (Segmentation Fault)\n");
        printf("Faulting address: %p\n", fault_addr);
        if (g_faults_this_run >= MAX_FAULTS_PER_RUN) {
            siglongjmp(jump_buffer, 3); // threshold exceeded
        }
        g_fault_addr = fault_addr;
        g_faults_this_run++;
        siglongjmp(jump_buffer, 2); // SIGSEV occured; retry
        break;
    case SIGBUS:
        printf("Caught SIGBUS (Bus Error)\n");
        break;
    case SIGFPE:
        printf("Caught SIGFPE (Floating Point Exception)\n");
        break;
    case SIGTRAP:
        printf("Caught SIGTRAP: EBREAK\n");
        break;
    default:
        printf("Caught signal %d\n", signo);
    }
    siglongjmp(jump_buffer, 1); // non-SIGSEGV fault
}

// Setup signal handlers
void setup_signal_handlers()
{
    // install alt stack (to allow clobbering of sp)
    stack_t ss;
    ss.ss_sp = alt_stack;
    ss.ss_size = sizeof(alt_stack);
    ss.ss_flags = 0;
    sigaltstack(&ss, NULL);

    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_sigaction = (void *)signal_trampoline;
    sa.sa_flags = SA_SIGINFO | SA_ONSTACK;

    sigemptyset(&sa.sa_mask);
    sigaction(SIGILL, &sa, NULL);
    sigaction(SIGSEGV, &sa, NULL);
    sigaction(SIGBUS, &sa, NULL);
    sigaction(SIGFPE, &sa, NULL);
    sigaction(SIGTRAP, &sa, NULL);
}

void unmap_vdso_vvar()
{
    FILE *maps = fopen("/proc/self/maps", "r");
    if (!maps)
    {
        perror("fopen /proc/self/maps");
        exit(EXIT_FAILURE);
    }

    char line[256];
    while (fgets(line, sizeof(line), maps))
    {
        if (strstr(line, "[vdso]") || strstr(line, "[vdso_data]") || strstr(line, "[vvar]"))
        {
            unsigned long start, end;
            if (sscanf(line, "%lx-%lx", &start, &end) == 2)
            {
                printf("Unmapping %lx - %lx\n", start, end);
                if (munmap((void *)start, end - start) != 0)
                {
                    perror("Warning: unmapping has failed!!");
                }
            }
        }
    }
    fclose(maps);
}

void print_reg_changes(uint64_t regs_before[32], uint64_t regs_after[32])
{

    for (int i = 0; i < 32; i++)
    {
        if (regs_before[i] != regs_after[i])
        {
            printf("%-4s changed: 0x%016lx -> 0x%016lx\n",
                   reg_names[i], regs_before[i], regs_after[i]);
        }
    }
}

void compare_reg_changes(uint64_t regs_before[32], uint64_t regs_after[32])
{
    for (int i = 0; i < 32; i++)
    {
        if (regs_before[i] != regs_after[i])
        {
            printf("WARNING: Register x%d differs: 0x%016lx -> 0x%016lx\n",
                   i, regs_before[i], regs_after[i]);
        }
    }
}
