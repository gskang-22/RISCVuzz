/* In RISCVuzz, a server is connected to many clients.
Since in this case we only have one C910 board (AKA 1 client), all code will be
run on the board instead.
However, the code will still be split into two sections (client and server) for ease of
futher expansion.
*/

#include "client.h"
#include "main.h"

extern void run_sandbox();
extern void test_start();
extern sigjmp_buf jump_buffer;
extern uint64_t regs_before[32];
extern uint64_t regs_after[32];

extern uint32_t fuzz_buffer2[];
extern size_t fuzz_buffer_len;

#define BUFFER_SIZE 64 // Number of elements in the random buffer
uint32_t fuzz_buffer3[BUFFER_SIZE];
uint8_t *sandbox_ptr;

extern size_t sandbox_pages;
extern size_t page_size;

#define MAX_MAPPED_PAGES 4
volatile sig_atomic_t g_faults_this_run = 0;
volatile uintptr_t g_fault_addr = 0;
static mapped_region_t *g_regions = NULL;
static size_t g_regions_len = 0;

static memdiff_t *g_diffs = NULL;
static size_t g_diffs_len = 0;
static size_t g_diffs_cap = 0;

uint32_t rand32()
{
    // rand() typically returns 15-bit values, so combine to get 32 bits
    uint32_t r = ((uint32_t)rand() & 0x7FFF);
    r |= ((uint32_t)rand() & 0x7FFF) << 15;
    r |= ((uint32_t)rand() & 0x3) << 30; // Only need 2 more bits
    return r;
}

uint32_t fuzz_buffer[] = {
    // instructions to be injected
    0x00000013, // nop
    0x10028027, // ghostwrite
    0xFFFFFFFF, // illegal instruction
    0x00008067, // ret
    0x00050067, // jump to x10
    0x00048067, // jump to x9
    0x00058067, // jump to x11
    0x0000a103, // lw x2, 0(x1)
    0x0142b183, // ld x3, 20(x5)
    0x01423183, // ld x3, 20(x4)
};

// Example: vse128.v v0, 0(t0) encoded as 0x10028027
uint32_t instrs[] = {
    0x00000013, // nop to be replaced

    0x00048067 // jalr x0, 0(x9)
};

void print_registers(const char *label, uint64_t regs[32])
{
    printf("=== %s ===\n", label);
    for (int i = 0; i < 32; i++)
    {
        printf("%-10s: 0x%016lx\n", reg_names[i], regs[i]);
    }
}

static void diffs_push(void *addr, uint8_t oldv, uint8_t newv)
{
    if (g_diffs_len == g_diffs_cap)
    {
        size_t ncap = g_diffs_cap ? g_diffs_cap * 2 : 256;
        g_diffs = realloc(g_diffs, ncap * sizeof(*g_diffs));
        if (!g_diffs)
        {
            perror("realloc");
            exit(1);
        }
        g_diffs_cap = ncap;
    }
    g_diffs[g_diffs_len++] = (memdiff_t){addr, oldv, newv};
}

static void report_diffs(uint8_t expected)
{
    g_diffs_len = 0;
    for (size_t i = 0; i < g_regions_len; i++)
    {
        uint8_t *p = (uint8_t *)g_regions[i].addr;
        size_t n = g_regions[i].len;
        for (size_t j = 0; j < n; j++)
        {
            uint8_t newv = p[j];
            if (newv != expected)
            {
                void *absaddr = (uint8_t *)g_regions[i].addr + j;
                diffs_push(absaddr, expected, newv);
            }
        }
    }

    for (size_t k = 0; k < g_diffs_len; k++)
    {
        fprintf(stdout, "CHG: addr=%p old=0x%02x new=0x%02x\n",
                g_diffs[k].addr, g_diffs[k].old_val, g_diffs[k].new_val);
    }
}

static bool region_exists(void *addr)
{
    for (size_t i = 0; i < g_regions_len; i++)
        if (g_regions[i].addr == addr)
            return true;
    return false;
}

// Takes an arbitrary address (p, which caused the segfault) and rounds it down to the start of the containing page
// Since mmap() only works at page-aligned addresses
static inline void *page_align_down(void *p)
{
    uintptr_t u = (uintptr_t)p;
    return (void *)(u & ~(uintptr_t)(page_size - 1));
}

// Maps two pages of memory (base and base + pagesize) starting at the faulting page
static void map_two_pages(void *base, uint8_t fill_byte)
{
    if (g_regions_len >= MAX_MAPPED_PAGES)
        return;

    if (!region_exists(base))
    {
        void *r = mmap(base, 2 * page_size,
                       PROT_READ | PROT_WRITE,
                       MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,
                       -1, 0);
        if (r == MAP_FAILED)
        {
            perror("mmap failed for lazy mapping");
            siglongjmp(jump_buffer, 4); // abort / skip this test case
        }
        else
        {
            // add region to g_regions array
            if (g_regions_len < MAX_MAPPED_PAGES)
            {
                g_regions[g_regions_len].addr = base;
                g_regions[g_regions_len].len = 2 * page_size;
                g_regions_len++;
            }
            // fill mapped regions with fill_byte
            for (size_t i = 0; i < g_regions_len; i++)
            {
                memset(g_regions[i].addr, fill_byte, g_regions[i].len);
            }
        }
    }
}

static void run_until_quiet(int fill_mode, uint8_t fill_byte)
{
    printf("running loop: %i\n", fill_byte);
    g_fault_addr = 0;

    int jump_rc = sigsetjmp(jump_buffer, 1);

    if (jump_rc == 0)
    {
        run_sandbox(sandbox_ptr);
	printf("no faults");
    }
    else if (jump_rc == 2)
    {
        // segv happened; map and retry
        void *base = page_align_down((void *)g_fault_addr);
        map_two_pages(base, fill_byte);
        run_sandbox(sandbox_ptr);
    }
    // if jump_rc == 1 || 3 || 4, fall through and return
    return;
}

int main()
{
    //   srand((unsigned)time(NULL));  // Seed randomness
    //   for (int i = 0; i < BUFFER_SIZE; i++) {
    //       fuzz_buffer[i] = rand32();
    //   }
    g_regions = calloc(MAX_MAPPED_PAGES, sizeof(*g_regions));
    setup_signal_handlers();
    unmap_vdso_vvar();
    sandbox_ptr = allocate_executable_buffer();
    printf("sandbox ptr: %p\n", sandbox_ptr);

    // for (size_t i = 0; i < (size_t)BUFFER_SIZE; i++)
    // for (size_t i = 0; i < fuzz_buffer_len; i++)
    for (size_t i = 0; i < sizeof(fuzz_buffer) / sizeof(uint32_t); i++)
    {
        printf("\n");
        printf("\n");
        printf("=== Running fuzz %zu: 0x%08x ===\n", i, fuzz_buffer[i]);
        // printf("=== Running fuzz %zu: 0x%08x ===\n", i, fuzz_buffer2[i]);
        // printf("=== Running fuzz %zu: 0x%08x ===\n", i, fuzz_buffer3[i]);

        // loops twice to check for differing results
        //        for (size_t x = 0; x < 2; x++)
        //        {

        // prepare sandbox
        prepare_sandbox(sandbox_ptr);
        instrs[0] = fuzz_buffer[i];
        inject_instructions(sandbox_ptr, instrs, sizeof(instrs) / sizeof(uint32_t));

        g_faults_this_run = 0;
        for (size_t i = 0; i < g_regions_len; i++)
        {
            munmap(g_regions[i].addr, g_regions[i].len);
        }
        g_regions_len = 0;

        int jump_rc = sigsetjmp(jump_buffer, 1);
        fprintf(stdout, "jump_rc: %d\n", jump_rc);
        if (jump_rc == 0)
        {
            run_sandbox(sandbox_ptr);
		    printf("no faults");
            continue; // no faults raised
        }
        else if (jump_rc == 1 || jump_rc == 4)
        {
            fprintf(stderr, "Skipping invalid instruction at fuzz %zu\n", i);
            fflush(stderr);
            // non SIGSEGV fault raised OR SIGSEGV fault in sandbox memory
            continue;
        }

        // SIGSEGV if code reaches here
        printf("Code raised sigsegv fault\n");

        run_until_quiet(1, 0x00);
        // report_diffs(0x00);
        
        prepare_sandbox(sandbox_ptr);
        instrs[0] = fuzz_buffer[i];
        inject_instructions(sandbox_ptr, instrs, sizeof(instrs) / sizeof(uint32_t));

        printf("g_faults_this_run = %d\n", g_faults_this_run);
        // printf("g_fault_addr = 0x%llx\n", (unsigned long long)g_fault_addr);

        // if (g_regions != NULL)
        // {
        //     printf("Mapped regions:\n");
        //     for (size_t i = 0; i < g_regions_len; i++)
        //     {
        //         printf("region %zu: addr=%p, len=%zu\n", i, g_regions[i].addr, g_regions[i].len);
        //     }
        // }
        // else
        // {
        //     printf("g_regions is NULL\n");
        // }

        run_until_quiet(1, 0xFF);
        // report_diffs(0xFF);
    }
    return 0;
}
